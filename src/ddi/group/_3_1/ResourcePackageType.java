//
// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, v2.2.4 
// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> 
// Any modifications to this file will be lost upon recompilation of the source schema. 
// Generated on: 2013.08.22 at 02:00:24 PM CEST 
//


package ddi.group._3_1;

import java.util.ArrayList;
import java.util.List;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlType;
import ddi.archive._3_1.ArchiveType;
import ddi.archive._3_1.OrganizationSchemeType;
import ddi.comparative._3_1.ComparisonType;
import ddi.conceptualcomponent._3_1.ConceptSchemeType;
import ddi.conceptualcomponent._3_1.GeographicLocationSchemeType;
import ddi.conceptualcomponent._3_1.GeographicStructureSchemeType;
import ddi.conceptualcomponent._3_1.UniverseSchemeType;
import ddi.datacollection._3_1.ControlConstructSchemeType;
import ddi.datacollection._3_1.InterviewerInstructionSchemeType;
import ddi.datacollection._3_1.QuestionSchemeType;
import ddi.ddiprofile._3_1.DDIProfileType;
import ddi.logicalproduct._3_1.CategorySchemeType;
import ddi.logicalproduct._3_1.CodeSchemeType;
import ddi.logicalproduct._3_1.NCubeSchemeType;
import ddi.logicalproduct._3_1.VariableSchemeType;
import ddi.physicaldataproduct._3_1.PhysicalStructureSchemeType;
import ddi.physicaldataproduct._3_1.RecordLayoutSchemeType;
import ddi.physicalinstance._3_1.PhysicalInstanceType;
import ddi.reusable._3_1.CitationType;
import ddi.reusable._3_1.CoverageType;
import ddi.reusable._3_1.FundingInformationType;
import ddi.reusable._3_1.IdentifiedStructuredStringType;
import ddi.reusable._3_1.MaintainableType;
import ddi.reusable._3_1.NoteType;
import ddi.reusable._3_1.OtherMaterialType;
import ddi.reusable._3_1.ReferenceType;


/**
 * The Resource Package is a specialized structure which is intended to hold reusable metadata such as Category Schemes, Variable Schemes, etc. These are placed in the Resource Package for the purpose of being included by reference in Groups and StudyUnits. The Resource Package has a similar structure to the Group.
 * 
 * <p>Java class for ResourcePackageType complex type.
 * 
 * <p>The following schema fragment specifies the expected content contained within this class.
 * 
 * <pre>
 * &lt;complexType name="ResourcePackageType">
 *   &lt;complexContent>
 *     &lt;extension base="{ddi:reusable:3_1}MaintainableType">
 *       &lt;sequence>
 *         &lt;element ref="{ddi:reusable:3_1}Citation" minOccurs="0"/>
 *         &lt;element ref="{ddi:group:3_1}Abstract" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element ref="{ddi:group:3_1}Purpose" maxOccurs="unbounded"/>
 *         &lt;element ref="{ddi:reusable:3_1}FundingInformation" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element ref="{ddi:reusable:3_1}Coverage" minOccurs="0"/>
 *         &lt;element ref="{ddi:reusable:3_1}UniverseReference" minOccurs="0"/>
 *         &lt;element ref="{ddi:reusable:3_1}OtherMaterial" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element ref="{ddi:archive:3_1}Archive" minOccurs="0"/>
 *         &lt;element ref="{ddi:reusable:3_1}Note" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element ref="{ddi:group:3_1}Concepts" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element ref="{ddi:group:3_1}DataCollection" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element ref="{ddi:group:3_1}LogicalProduct" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element ref="{ddi:group:3_1}PhysicalDataProduct" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element ref="{ddi:physicalinstance:3_1}PhysicalInstance" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element ref="{ddi:comparative:3_1}Comparison" minOccurs="0"/>
 *         &lt;element ref="{ddi:ddiprofile:3_1}DDIProfile" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element ref="{ddi:group:3_1}DDIProfileReference" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element ref="{ddi:archive:3_1}OrganizationScheme" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element ref="{ddi:conceptualcomponent:3_1}ConceptScheme" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element ref="{ddi:conceptualcomponent:3_1}UniverseScheme" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element ref="{ddi:conceptualcomponent:3_1}GeographicStructureScheme" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element ref="{ddi:conceptualcomponent:3_1}GeographicLocationScheme" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element ref="{ddi:datacollection:3_1}InterviewerInstructionScheme" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element ref="{ddi:datacollection:3_1}ControlConstructScheme" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element ref="{ddi:datacollection:3_1}QuestionScheme" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element ref="{ddi:logicalproduct:3_1}CategoryScheme" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element ref="{ddi:logicalproduct:3_1}CodeScheme" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element ref="{ddi:logicalproduct:3_1}NCubeScheme" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element ref="{ddi:logicalproduct:3_1}VariableScheme" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element ref="{ddi:physicaldataproduct:3_1}PhysicalStructureScheme" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element ref="{ddi:physicaldataproduct:3_1}RecordLayoutScheme" maxOccurs="unbounded" minOccurs="0"/>
 *       &lt;/sequence>
 *     &lt;/extension>
 *   &lt;/complexContent>
 * &lt;/complexType>
 * </pre>
 * 
 * 
 */
@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "ResourcePackageType", propOrder = {
    "citation",
    "_abstract",
    "purpose",
    "fundingInformation",
    "coverage",
    "universeReference",
    "otherMaterial",
    "archive",
    "note",
    "concepts",
    "dataCollection",
    "logicalProduct",
    "physicalDataProduct",
    "physicalInstance",
    "comparison",
    "ddiProfile",
    "ddiProfileReference",
    "organizationScheme",
    "conceptScheme",
    "universeScheme",
    "geographicStructureScheme",
    "geographicLocationScheme",
    "interviewerInstructionScheme",
    "controlConstructScheme",
    "questionScheme",
    "categoryScheme",
    "codeScheme",
    "nCubeScheme",
    "variableScheme",
    "physicalStructureScheme",
    "recordLayoutScheme"
})
public class ResourcePackageType
    extends MaintainableType
{

    @XmlElement(name = "Citation", namespace = "ddi:reusable:3_1")
    protected CitationType citation;
    @XmlElement(name = "Abstract")
    protected List<IdentifiedStructuredStringType> _abstract;
    @XmlElement(name = "Purpose", required = true)
    protected List<IdentifiedStructuredStringType> purpose;
    @XmlElement(name = "FundingInformation", namespace = "ddi:reusable:3_1")
    protected List<FundingInformationType> fundingInformation;
    @XmlElement(name = "Coverage", namespace = "ddi:reusable:3_1")
    protected CoverageType coverage;
    @XmlElement(name = "UniverseReference", namespace = "ddi:reusable:3_1")
    protected ReferenceType universeReference;
    @XmlElement(name = "OtherMaterial", namespace = "ddi:reusable:3_1")
    protected List<OtherMaterialType> otherMaterial;
    @XmlElement(name = "Archive", namespace = "ddi:archive:3_1")
    protected ArchiveType archive;
    @XmlElement(name = "Note", namespace = "ddi:reusable:3_1")
    protected List<NoteType> note;
    @XmlElement(name = "Concepts")
    protected List<ConceptType> concepts;
    @XmlElement(name = "DataCollection")
    protected List<DataCollectionType> dataCollection;
    @XmlElement(name = "LogicalProduct")
    protected List<LogicalProductType> logicalProduct;
    @XmlElement(name = "PhysicalDataProduct")
    protected List<PhysicalDataProductType> physicalDataProduct;
    @XmlElement(name = "PhysicalInstance", namespace = "ddi:physicalinstance:3_1")
    protected List<PhysicalInstanceType> physicalInstance;
    @XmlElement(name = "Comparison", namespace = "ddi:comparative:3_1")
    protected ComparisonType comparison;
    @XmlElement(name = "DDIProfile", namespace = "ddi:ddiprofile:3_1")
    protected List<DDIProfileType> ddiProfile;
    @XmlElement(name = "DDIProfileReference")
    protected List<ReferenceType> ddiProfileReference;
    @XmlElement(name = "OrganizationScheme", namespace = "ddi:archive:3_1")
    protected List<OrganizationSchemeType> organizationScheme;
    @XmlElement(name = "ConceptScheme", namespace = "ddi:conceptualcomponent:3_1")
    protected List<ConceptSchemeType> conceptScheme;
    @XmlElement(name = "UniverseScheme", namespace = "ddi:conceptualcomponent:3_1")
    protected List<UniverseSchemeType> universeScheme;
    @XmlElement(name = "GeographicStructureScheme", namespace = "ddi:conceptualcomponent:3_1")
    protected List<GeographicStructureSchemeType> geographicStructureScheme;
    @XmlElement(name = "GeographicLocationScheme", namespace = "ddi:conceptualcomponent:3_1")
    protected List<GeographicLocationSchemeType> geographicLocationScheme;
    @XmlElement(name = "InterviewerInstructionScheme", namespace = "ddi:datacollection:3_1")
    protected List<InterviewerInstructionSchemeType> interviewerInstructionScheme;
    @XmlElement(name = "ControlConstructScheme", namespace = "ddi:datacollection:3_1")
    protected List<ControlConstructSchemeType> controlConstructScheme;
    @XmlElement(name = "QuestionScheme", namespace = "ddi:datacollection:3_1")
    protected List<QuestionSchemeType> questionScheme;
    @XmlElement(name = "CategoryScheme", namespace = "ddi:logicalproduct:3_1")
    protected List<CategorySchemeType> categoryScheme;
    @XmlElement(name = "CodeScheme", namespace = "ddi:logicalproduct:3_1")
    protected List<CodeSchemeType> codeScheme;
    @XmlElement(name = "NCubeScheme", namespace = "ddi:logicalproduct:3_1")
    protected List<NCubeSchemeType> nCubeScheme;
    @XmlElement(name = "VariableScheme", namespace = "ddi:logicalproduct:3_1")
    protected List<VariableSchemeType> variableScheme;
    @XmlElement(name = "PhysicalStructureScheme", namespace = "ddi:physicaldataproduct:3_1")
    protected List<PhysicalStructureSchemeType> physicalStructureScheme;
    @XmlElement(name = "RecordLayoutScheme", namespace = "ddi:physicaldataproduct:3_1")
    protected List<RecordLayoutSchemeType> recordLayoutScheme;

    /**
     * Includes bibliographic citation information for the resource package.
     * 
     * @return
     *     possible object is
     *     {@link CitationType }
     *     
     */
    public CitationType getCitation() {
        return citation;
    }

    /**
     * Sets the value of the citation property.
     * 
     * @param value
     *     allowed object is
     *     {@link CitationType }
     *     
     */
    public void setCitation(CitationType value) {
        this.citation = value;
    }

    /**
     * Human-readable summary of the material in the resource package.Gets the value of the abstract property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the abstract property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getAbstract().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link IdentifiedStructuredStringType }
     * 
     * 
     */
    public List<IdentifiedStructuredStringType> getAbstract() {
        if (_abstract == null) {
            _abstract = new ArrayList<IdentifiedStructuredStringType>();
        }
        return this._abstract;
    }

    /**
     * Human-readable explanation of why the creator grouped these objects together for reuse. When creating documentation from incomplete legacy materials this field may contain a statement such as "Unavailable", "Not provided by creator", or other similar statements.Gets the value of the purpose property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the purpose property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getPurpose().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link IdentifiedStructuredStringType }
     * 
     * 
     */
    public List<IdentifiedStructuredStringType> getPurpose() {
        if (purpose == null) {
            purpose = new ArrayList<IdentifiedStructuredStringType>();
        }
        return this.purpose;
    }

    /**
     * Provides information about the agency and grant(s) which funded the resource package.Gets the value of the fundingInformation property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the fundingInformation property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getFundingInformation().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link FundingInformationType }
     * 
     * 
     */
    public List<FundingInformationType> getFundingInformation() {
        if (fundingInformation == null) {
            fundingInformation = new ArrayList<FundingInformationType>();
        }
        return this.fundingInformation;
    }

    /**
     * Documents the topical, spatial, and temporal coverage of the resource package.
     * 
     * @return
     *     possible object is
     *     {@link CoverageType }
     *     
     */
    public CoverageType getCoverage() {
        return coverage;
    }

    /**
     * Sets the value of the coverage property.
     * 
     * @param value
     *     allowed object is
     *     {@link CoverageType }
     *     
     */
    public void setCoverage(CoverageType value) {
        this.coverage = value;
    }

    /**
     * References the universe or sub-universe of the resource package.
     * 
     * @return
     *     possible object is
     *     {@link ReferenceType }
     *     
     */
    public ReferenceType getUniverseReference() {
        return universeReference;
    }

    /**
     * Sets the value of the universeReference property.
     * 
     * @param value
     *     allowed object is
     *     {@link ReferenceType }
     *     
     */
    public void setUniverseReference(ReferenceType value) {
        this.universeReference = value;
    }

    /**
     * References other materials related to the resource package.Gets the value of the otherMaterial property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the otherMaterial property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getOtherMaterial().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link OtherMaterialType }
     * 
     * 
     */
    public List<OtherMaterialType> getOtherMaterial() {
        if (otherMaterial == null) {
            otherMaterial = new ArrayList<OtherMaterialType>();
        }
        return this.otherMaterial;
    }

    /**
     * Provides archive-specific information, including a listing of items.
     * 
     * @return
     *     possible object is
     *     {@link ArchiveType }
     *     
     */
    public ArchiveType getArchive() {
        return archive;
    }

    /**
     * Sets the value of the archive property.
     * 
     * @param value
     *     allowed object is
     *     {@link ArchiveType }
     *     
     */
    public void setArchive(ArchiveType value) {
        this.archive = value;
    }

    /**
     * Notes regarding the group as a whole, or pertaining to all members of the resource package.Gets the value of the note property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the note property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getNote().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link NoteType }
     * 
     * 
     */
    public List<NoteType> getNote() {
        if (note == null) {
            note = new ArrayList<NoteType>();
        }
        return this.note;
    }

    /**
     * Documents, or references, concept schemes, universe schemes, geographic structure and geographic location schemes.Gets the value of the concepts property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the concepts property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getConcepts().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link ConceptType }
     * 
     * 
     */
    public List<ConceptType> getConcepts() {
        if (concepts == null) {
            concepts = new ArrayList<ConceptType>();
        }
        return this.concepts;
    }

    /**
     * Reusable documentation regarding the data collection process.Gets the value of the dataCollection property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the dataCollection property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getDataCollection().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link DataCollectionType }
     * 
     * 
     */
    public List<DataCollectionType> getDataCollection() {
        if (dataCollection == null) {
            dataCollection = new ArrayList<DataCollectionType>();
        }
        return this.dataCollection;
    }

    /**
     * Reusable  documentation pertaining to the logical description of data.Gets the value of the logicalProduct property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the logicalProduct property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getLogicalProduct().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link LogicalProductType }
     * 
     * 
     */
    public List<LogicalProductType> getLogicalProduct() {
        if (logicalProduct == null) {
            logicalProduct = new ArrayList<LogicalProductType>();
        }
        return this.logicalProduct;
    }

    /**
     * Reusable documentation regarding a physical data product.Gets the value of the physicalDataProduct property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the physicalDataProduct property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getPhysicalDataProduct().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link PhysicalDataProductType }
     * 
     * 
     */
    public List<PhysicalDataProductType> getPhysicalDataProduct() {
        if (physicalDataProduct == null) {
            physicalDataProduct = new ArrayList<PhysicalDataProductType>();
        }
        return this.physicalDataProduct;
    }

    /**
     * Gets the value of the physicalInstance property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the physicalInstance property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getPhysicalInstance().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link PhysicalInstanceType }
     * 
     * 
     */
    public List<PhysicalInstanceType> getPhysicalInstance() {
        if (physicalInstance == null) {
            physicalInstance = new ArrayList<PhysicalInstanceType>();
        }
        return this.physicalInstance;
    }

    /**
     * Provides documentation regarding the comparability of various DDI resources.
     * 
     * @return
     *     possible object is
     *     {@link ComparisonType }
     *     
     */
    public ComparisonType getComparison() {
        return comparison;
    }

    /**
     * Sets the value of the comparison property.
     * 
     * @param value
     *     allowed object is
     *     {@link ComparisonType }
     *     
     */
    public void setComparison(ComparisonType value) {
        this.comparison = value;
    }

    /**
     * Contains a reusable DDI Profile.Gets the value of the ddiProfile property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the ddiProfile property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getDDIProfile().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link DDIProfileType }
     * 
     * 
     */
    public List<DDIProfileType> getDDIProfile() {
        if (ddiProfile == null) {
            ddiProfile = new ArrayList<DDIProfileType>();
        }
        return this.ddiProfile;
    }

    /**
     * References a DDI Profile used by the resource package.Gets the value of the ddiProfileReference property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the ddiProfileReference property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getDDIProfileReference().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link ReferenceType }
     * 
     * 
     */
    public List<ReferenceType> getDDIProfileReference() {
        if (ddiProfileReference == null) {
            ddiProfileReference = new ArrayList<ReferenceType>();
        }
        return this.ddiProfileReference;
    }

    /**
     * Gets the value of the organizationScheme property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the organizationScheme property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getOrganizationScheme().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link OrganizationSchemeType }
     * 
     * 
     */
    public List<OrganizationSchemeType> getOrganizationScheme() {
        if (organizationScheme == null) {
            organizationScheme = new ArrayList<OrganizationSchemeType>();
        }
        return this.organizationScheme;
    }

    /**
     * Gets the value of the conceptScheme property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the conceptScheme property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getConceptScheme().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link ConceptSchemeType }
     * 
     * 
     */
    public List<ConceptSchemeType> getConceptScheme() {
        if (conceptScheme == null) {
            conceptScheme = new ArrayList<ConceptSchemeType>();
        }
        return this.conceptScheme;
    }

    /**
     * Gets the value of the universeScheme property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the universeScheme property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getUniverseScheme().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link UniverseSchemeType }
     * 
     * 
     */
    public List<UniverseSchemeType> getUniverseScheme() {
        if (universeScheme == null) {
            universeScheme = new ArrayList<UniverseSchemeType>();
        }
        return this.universeScheme;
    }

    /**
     * Gets the value of the geographicStructureScheme property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the geographicStructureScheme property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getGeographicStructureScheme().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link GeographicStructureSchemeType }
     * 
     * 
     */
    public List<GeographicStructureSchemeType> getGeographicStructureScheme() {
        if (geographicStructureScheme == null) {
            geographicStructureScheme = new ArrayList<GeographicStructureSchemeType>();
        }
        return this.geographicStructureScheme;
    }

    /**
     * Gets the value of the geographicLocationScheme property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the geographicLocationScheme property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getGeographicLocationScheme().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link GeographicLocationSchemeType }
     * 
     * 
     */
    public List<GeographicLocationSchemeType> getGeographicLocationScheme() {
        if (geographicLocationScheme == null) {
            geographicLocationScheme = new ArrayList<GeographicLocationSchemeType>();
        }
        return this.geographicLocationScheme;
    }

    /**
     * Gets the value of the interviewerInstructionScheme property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the interviewerInstructionScheme property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getInterviewerInstructionScheme().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link InterviewerInstructionSchemeType }
     * 
     * 
     */
    public List<InterviewerInstructionSchemeType> getInterviewerInstructionScheme() {
        if (interviewerInstructionScheme == null) {
            interviewerInstructionScheme = new ArrayList<InterviewerInstructionSchemeType>();
        }
        return this.interviewerInstructionScheme;
    }

    /**
     * Gets the value of the controlConstructScheme property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the controlConstructScheme property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getControlConstructScheme().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link ControlConstructSchemeType }
     * 
     * 
     */
    public List<ControlConstructSchemeType> getControlConstructScheme() {
        if (controlConstructScheme == null) {
            controlConstructScheme = new ArrayList<ControlConstructSchemeType>();
        }
        return this.controlConstructScheme;
    }

    /**
     * Gets the value of the questionScheme property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the questionScheme property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getQuestionScheme().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link QuestionSchemeType }
     * 
     * 
     */
    public List<QuestionSchemeType> getQuestionScheme() {
        if (questionScheme == null) {
            questionScheme = new ArrayList<QuestionSchemeType>();
        }
        return this.questionScheme;
    }

    /**
     * Gets the value of the categoryScheme property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the categoryScheme property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getCategoryScheme().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link CategorySchemeType }
     * 
     * 
     */
    public List<CategorySchemeType> getCategoryScheme() {
        if (categoryScheme == null) {
            categoryScheme = new ArrayList<CategorySchemeType>();
        }
        return this.categoryScheme;
    }

    /**
     * Gets the value of the codeScheme property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the codeScheme property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getCodeScheme().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link CodeSchemeType }
     * 
     * 
     */
    public List<CodeSchemeType> getCodeScheme() {
        if (codeScheme == null) {
            codeScheme = new ArrayList<CodeSchemeType>();
        }
        return this.codeScheme;
    }

    /**
     * Gets the value of the nCubeScheme property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the nCubeScheme property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getNCubeScheme().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link NCubeSchemeType }
     * 
     * 
     */
    public List<NCubeSchemeType> getNCubeScheme() {
        if (nCubeScheme == null) {
            nCubeScheme = new ArrayList<NCubeSchemeType>();
        }
        return this.nCubeScheme;
    }

    /**
     * Gets the value of the variableScheme property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the variableScheme property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getVariableScheme().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link VariableSchemeType }
     * 
     * 
     */
    public List<VariableSchemeType> getVariableScheme() {
        if (variableScheme == null) {
            variableScheme = new ArrayList<VariableSchemeType>();
        }
        return this.variableScheme;
    }

    /**
     * Gets the value of the physicalStructureScheme property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the physicalStructureScheme property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getPhysicalStructureScheme().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link PhysicalStructureSchemeType }
     * 
     * 
     */
    public List<PhysicalStructureSchemeType> getPhysicalStructureScheme() {
        if (physicalStructureScheme == null) {
            physicalStructureScheme = new ArrayList<PhysicalStructureSchemeType>();
        }
        return this.physicalStructureScheme;
    }

    /**
     * Gets the value of the recordLayoutScheme property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the recordLayoutScheme property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getRecordLayoutScheme().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link RecordLayoutSchemeType }
     * 
     * 
     */
    public List<RecordLayoutSchemeType> getRecordLayoutScheme() {
        if (recordLayoutScheme == null) {
            recordLayoutScheme = new ArrayList<RecordLayoutSchemeType>();
        }
        return this.recordLayoutScheme;
    }

}
