//
// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, v2.2.4 
// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> 
// Any modifications to this file will be lost upon recompilation of the source schema. 
// Generated on: 2013.08.22 at 02:00:24 PM CEST 
//


package ddi.logicalproduct._3_1;

import java.util.ArrayList;
import java.util.List;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlType;
import ddi.reusable._3_1.LabelType;
import ddi.reusable._3_1.MaintainableType;
import ddi.reusable._3_1.NameType;
import ddi.reusable._3_1.SchemeReferenceType;
import ddi.reusable._3_1.StructuredStringType;


/**
 * Describes the structure of a Code Scheme.
 * 
 * <p>Java class for CodeSchemeType complex type.
 * 
 * <p>The following schema fragment specifies the expected content contained within this class.
 * 
 * <pre>
 * &lt;complexType name="CodeSchemeType">
 *   &lt;complexContent>
 *     &lt;extension base="{ddi:reusable:3_1}MaintainableType">
 *       &lt;sequence>
 *         &lt;element ref="{ddi:logicalproduct:3_1}CodeSchemeName" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element ref="{ddi:reusable:3_1}Label" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element ref="{ddi:reusable:3_1}Description" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element ref="{ddi:logicalproduct:3_1}CodeSchemeReference" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element ref="{ddi:logicalproduct:3_1}CategorySchemeReference" minOccurs="0"/>
 *         &lt;element ref="{ddi:logicalproduct:3_1}HierarchyType" minOccurs="0"/>
 *         &lt;element ref="{ddi:logicalproduct:3_1}Level" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element ref="{ddi:logicalproduct:3_1}Code" maxOccurs="unbounded" minOccurs="0"/>
 *       &lt;/sequence>
 *     &lt;/extension>
 *   &lt;/complexContent>
 * &lt;/complexType>
 * </pre>
 * 
 * 
 */
@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "CodeSchemeType", propOrder = {
    "codeSchemeName",
    "label",
    "description",
    "codeSchemeReference",
    "categorySchemeReference",
    "hierarchyType",
    "level",
    "code"
})
public class CodeSchemeType
    extends MaintainableType
{

    @XmlElement(name = "CodeSchemeName")
    protected List<NameType> codeSchemeName;
    @XmlElement(name = "Label", namespace = "ddi:reusable:3_1")
    protected List<LabelType> label;
    @XmlElement(name = "Description", namespace = "ddi:reusable:3_1")
    protected List<StructuredStringType> description;
    @XmlElement(name = "CodeSchemeReference")
    protected List<CodeSchemeReferenceType> codeSchemeReference;
    @XmlElement(name = "CategorySchemeReference")
    protected SchemeReferenceType categorySchemeReference;
    @XmlElement(name = "HierarchyType")
    protected HierarchyCodeType hierarchyType;
    @XmlElement(name = "Level")
    protected List<LevelType> level;
    @XmlElement(name = "Code")
    protected List<CodeType> code;

    /**
     * Gets the value of the codeSchemeName property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the codeSchemeName property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getCodeSchemeName().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link NameType }
     * 
     * 
     */
    public List<NameType> getCodeSchemeName() {
        if (codeSchemeName == null) {
            codeSchemeName = new ArrayList<NameType>();
        }
        return this.codeSchemeName;
    }

    /**
     * A display label for the code scheme.Gets the value of the label property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the label property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getLabel().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link LabelType }
     * 
     * 
     */
    public List<LabelType> getLabel() {
        if (label == null) {
            label = new ArrayList<LabelType>();
        }
        return this.label;
    }

    /**
     * A further human-readable description of the code scheme.Gets the value of the description property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the description property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getDescription().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link StructuredStringType }
     * 
     * 
     */
    public List<StructuredStringType> getDescription() {
        if (description == null) {
            description = new ArrayList<StructuredStringType>();
        }
        return this.description;
    }

    /**
     * Allows for inclusion by reference of another code scheme Gets the value of the codeSchemeReference property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the codeSchemeReference property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getCodeSchemeReference().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link CodeSchemeReferenceType }
     * 
     * 
     */
    public List<CodeSchemeReferenceType> getCodeSchemeReference() {
        if (codeSchemeReference == null) {
            codeSchemeReference = new ArrayList<CodeSchemeReferenceType>();
        }
        return this.codeSchemeReference;
    }

    /**
     * Reference to a default category scheme, with the assumption that all categories referenced by the subsequent codes are part of it, unless overwritten by the scheme reference in the CategoryReference field of the code.
     * 
     * @return
     *     possible object is
     *     {@link SchemeReferenceType }
     *     
     */
    public SchemeReferenceType getCategorySchemeReference() {
        return categorySchemeReference;
    }

    /**
     * Sets the value of the categorySchemeReference property.
     * 
     * @param value
     *     allowed object is
     *     {@link SchemeReferenceType }
     *     
     */
    public void setCategorySchemeReference(SchemeReferenceType value) {
        this.categorySchemeReference = value;
    }

    /**
     * Identifies the type of hierarchy used in the nesting of categories. Possible values are Regular and Irregular. A regular nesting indicates that the category hierarchy is consistent at all lower levels of the hierarchy, i.e., the lowest levels of the hierarchy are at the same level for every branch on the hierarchy.
     * 
     * @return
     *     possible object is
     *     {@link HierarchyCodeType }
     *     
     */
    public HierarchyCodeType getHierarchyType() {
        return hierarchyType;
    }

    /**
     * Sets the value of the hierarchyType property.
     * 
     * @param value
     *     allowed object is
     *     {@link HierarchyCodeType }
     *     
     */
    public void setHierarchyType(HierarchyCodeType value) {
        this.hierarchyType = value;
    }

    /**
     *  to describe the levels of the code hierarchy. The level describes the nesting structure of a hierarchical coding structure. Note that the attribute levelNumber is used for referencing specific codes to their level identifier.Gets the value of the level property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the level property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getLevel().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link LevelType }
     * 
     * 
     */
    public List<LevelType> getLevel() {
        if (level == null) {
            level = new ArrayList<LevelType>();
        }
        return this.level;
    }

    /**
     * Includes a code value, references  the category label, and describes the code's position in a hierarchy.Gets the value of the code property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the code property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getCode().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link CodeType }
     * 
     * 
     */
    public List<CodeType> getCode() {
        if (code == null) {
            code = new ArrayList<CodeType>();
        }
        return this.code;
    }

}
