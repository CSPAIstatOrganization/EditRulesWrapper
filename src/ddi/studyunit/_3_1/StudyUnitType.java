//
// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, v2.2.4 
// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> 
// Any modifications to this file will be lost upon recompilation of the source schema. 
// Generated on: 2013.08.22 at 02:00:24 PM CEST 
//


package ddi.studyunit._3_1;

import java.util.ArrayList;
import java.util.List;
import javax.xml.bind.JAXBElement;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlElementRef;
import javax.xml.bind.annotation.XmlType;
import ddi.archive._3_1.ArchiveType;
import ddi.conceptualcomponent._3_1.ConceptualComponentType;
import ddi.datacollection._3_1.DataCollectionType;
import ddi.ddiprofile._3_1.DDIProfileType;
import ddi.logicalproduct._3_1.BaseLogicalProductType;
import ddi.logicalproduct._3_1.LogicalProductType;
import ddi.logicalproduct._3_1.NCubeLogicalProductType;
import ddi.physicaldataproduct._3_1.PhysicalDataProductType;
import ddi.physicalinstance._3_1.PhysicalInstanceType;
import ddi.reusable._3_1.CitationType;
import ddi.reusable._3_1.CodeValueType;
import ddi.reusable._3_1.CoverageType;
import ddi.reusable._3_1.EmbargoType;
import ddi.reusable._3_1.FundingInformationType;
import ddi.reusable._3_1.IdentifiedStructuredStringType;
import ddi.reusable._3_1.InternationalStringType;
import ddi.reusable._3_1.MaintainableType;
import ddi.reusable._3_1.NoteType;
import ddi.reusable._3_1.OtherMaterialType;
import ddi.reusable._3_1.ReferenceType;
import ddi.reusable._3_1.SeriesStatementType;


/**
 * Describes the study unit which encompasses specified data collection processes as well as their resultant data products. This includes all of it's associated documentation and metadata. A Study Unit corresponds to the "study" as described in a traditional codebook, although a codebook may relate to only a single data product from the study. Typically, a 2.* or earlier version can have its content marked up in DDI version 3.0 with a single study unit containing the bulk of the documentation and metadata. Multiple data products from the same "study" (typically separate DDI instances in 2.* and earlier) can be combined in a single 3.0 instance. (See "DDI 3.0 Documentation, Part 1: Basic Structures" for more detail regarding the mappings between 2.* and 3.0.)
 * 
 * <p>Java class for StudyUnitType complex type.
 * 
 * <p>The following schema fragment specifies the expected content contained within this class.
 * 
 * <pre>
 * &lt;complexType name="StudyUnitType">
 *   &lt;complexContent>
 *     &lt;extension base="{ddi:reusable:3_1}MaintainableType">
 *       &lt;sequence>
 *         &lt;element ref="{ddi:reusable:3_1}Citation"/>
 *         &lt;element ref="{ddi:studyunit:3_1}Abstract" maxOccurs="unbounded"/>
 *         &lt;element ref="{ddi:reusable:3_1}UniverseReference" maxOccurs="unbounded"/>
 *         &lt;element ref="{ddi:reusable:3_1}SeriesStatement" minOccurs="0"/>
 *         &lt;element ref="{ddi:reusable:3_1}FundingInformation" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element ref="{ddi:studyunit:3_1}Purpose" maxOccurs="unbounded"/>
 *         &lt;element ref="{ddi:reusable:3_1}Coverage" minOccurs="0"/>
 *         &lt;element ref="{ddi:reusable:3_1}AnalysisUnit" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element ref="{ddi:studyunit:3_1}AnalysisUnitsCovered" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element ref="{ddi:studyunit:3_1}KindOfData" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element ref="{ddi:reusable:3_1}OtherMaterial" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element ref="{ddi:reusable:3_1}Note" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element ref="{ddi:reusable:3_1}Embargo" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element ref="{ddi:conceptualcomponent:3_1}ConceptualComponent" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element ref="{ddi:studyunit:3_1}ConceptualComponentReference" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element ref="{ddi:datacollection:3_1}DataCollection" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element ref="{ddi:studyunit:3_1}DataCollectionReference" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element ref="{ddi:logicalproduct:3_1}BaseLogicalProduct" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element ref="{ddi:studyunit:3_1}LogicalProductReference" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element ref="{ddi:physicaldataproduct:3_1}PhysicalDataProduct" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element ref="{ddi:studyunit:3_1}PhysicalDataProductReference" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element ref="{ddi:physicalinstance:3_1}PhysicalInstance" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element ref="{ddi:studyunit:3_1}PhysicalInstanceReference" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element ref="{ddi:archive:3_1}Archive" minOccurs="0"/>
 *         &lt;element ref="{ddi:studyunit:3_1}ArchiveReference" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element ref="{ddi:ddiprofile:3_1}DDIProfile" maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;element ref="{ddi:studyunit:3_1}DDIProfileReference" maxOccurs="unbounded" minOccurs="0"/>
 *       &lt;/sequence>
 *     &lt;/extension>
 *   &lt;/complexContent>
 * &lt;/complexType>
 * </pre>
 * 
 * 
 */
@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "StudyUnitType", propOrder = {
    "citation",
    "_abstract",
    "universeReference",
    "seriesStatement",
    "fundingInformation",
    "purpose",
    "coverage",
    "analysisUnit",
    "analysisUnitsCovered",
    "kindOfData",
    "otherMaterial",
    "note",
    "embargo",
    "conceptualComponent",
    "conceptualComponentReference",
    "dataCollection",
    "dataCollectionReference",
    "baseLogicalProduct",
    "logicalProductReference",
    "physicalDataProduct",
    "physicalDataProductReference",
    "physicalInstance",
    "physicalInstanceReference",
    "archive",
    "archiveReference",
    "ddiProfile",
    "ddiProfileReference"
})
public class StudyUnitType
    extends MaintainableType
{

    @XmlElement(name = "Citation", namespace = "ddi:reusable:3_1", required = true)
    protected CitationType citation;
    @XmlElement(name = "Abstract", required = true)
    protected List<IdentifiedStructuredStringType> _abstract;
    @XmlElement(name = "UniverseReference", namespace = "ddi:reusable:3_1", required = true)
    protected List<ReferenceType> universeReference;
    @XmlElement(name = "SeriesStatement", namespace = "ddi:reusable:3_1")
    protected SeriesStatementType seriesStatement;
    @XmlElement(name = "FundingInformation", namespace = "ddi:reusable:3_1")
    protected List<FundingInformationType> fundingInformation;
    @XmlElement(name = "Purpose", required = true)
    protected List<IdentifiedStructuredStringType> purpose;
    @XmlElement(name = "Coverage", namespace = "ddi:reusable:3_1")
    protected CoverageType coverage;
    @XmlElement(name = "AnalysisUnit", namespace = "ddi:reusable:3_1")
    protected List<CodeValueType> analysisUnit;
    @XmlElement(name = "AnalysisUnitsCovered")
    protected List<InternationalStringType> analysisUnitsCovered;
    @XmlElement(name = "KindOfData")
    protected List<KindOfDataType> kindOfData;
    @XmlElement(name = "OtherMaterial", namespace = "ddi:reusable:3_1")
    protected List<OtherMaterialType> otherMaterial;
    @XmlElement(name = "Note", namespace = "ddi:reusable:3_1")
    protected List<NoteType> note;
    @XmlElement(name = "Embargo", namespace = "ddi:reusable:3_1")
    protected List<EmbargoType> embargo;
    @XmlElement(name = "ConceptualComponent", namespace = "ddi:conceptualcomponent:3_1")
    protected List<ConceptualComponentType> conceptualComponent;
    @XmlElement(name = "ConceptualComponentReference")
    protected List<ReferenceType> conceptualComponentReference;
    @XmlElement(name = "DataCollection", namespace = "ddi:datacollection:3_1")
    protected List<DataCollectionType> dataCollection;
    @XmlElement(name = "DataCollectionReference")
    protected List<ReferenceType> dataCollectionReference;
    @XmlElementRef(name = "BaseLogicalProduct", namespace = "ddi:logicalproduct:3_1", type = JAXBElement.class, required = false)
    protected List<JAXBElement<? extends BaseLogicalProductType>> baseLogicalProduct;
    @XmlElement(name = "LogicalProductReference")
    protected List<ReferenceType> logicalProductReference;
    @XmlElement(name = "PhysicalDataProduct", namespace = "ddi:physicaldataproduct:3_1")
    protected List<PhysicalDataProductType> physicalDataProduct;
    @XmlElement(name = "PhysicalDataProductReference")
    protected List<ReferenceType> physicalDataProductReference;
    @XmlElement(name = "PhysicalInstance", namespace = "ddi:physicalinstance:3_1")
    protected List<PhysicalInstanceType> physicalInstance;
    @XmlElement(name = "PhysicalInstanceReference")
    protected List<ReferenceType> physicalInstanceReference;
    @XmlElement(name = "Archive", namespace = "ddi:archive:3_1")
    protected ArchiveType archive;
    @XmlElement(name = "ArchiveReference")
    protected List<ReferenceType> archiveReference;
    @XmlElement(name = "DDIProfile", namespace = "ddi:ddiprofile:3_1")
    protected List<DDIProfileType> ddiProfile;
    @XmlElement(name = "DDIProfileReference")
    protected List<ReferenceType> ddiProfileReference;

    /**
     * Encodes the bibliographic information describing the original study.
     * 
     * @return
     *     possible object is
     *     {@link CitationType }
     *     
     */
    public CitationType getCitation() {
        return citation;
    }

    /**
     * Sets the value of the citation property.
     * 
     * @param value
     *     allowed object is
     *     {@link CitationType }
     *     
     */
    public void setCitation(CitationType value) {
        this.citation = value;
    }

    /**
     * A human-readable abstract of the study unit describing the nature and scope of the data collection, special characteristics of its content. Note that detailed information on the purpose of the study and structured coverage information are to be entered in Purpose and Coverage. During study development, or when creating documentation from incomplete legacy materials, this field should contain an appropriate statement such as "Under development", "Unavailable", "Not provided by creator", or some other similar statement.Gets the value of the abstract property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the abstract property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getAbstract().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link IdentifiedStructuredStringType }
     * 
     * 
     */
    public List<IdentifiedStructuredStringType> getAbstract() {
        if (_abstract == null) {
            _abstract = new ArrayList<IdentifiedStructuredStringType>();
        }
        return this._abstract;
    }

    /**
     * Reference to the universe statement from the universe scheme, describing the group of persons or other elements that are the object of research and to which any analytic results refer. Age, nationality, and residence commonly help to delineate a given universe, but any of a number of factors may be involved, such as sex, race, income, veteran status, criminal convictions, etc. The universe may consist of elements other than persons, such as housing units, court cases, deaths, countries, etc. In general, it should be possible to tell from the description of the universe whether a given individual or element (hypothetical or real) is a member of the population under study. A universe may be described as "inclusive" or "exclusive". This studyunit level reference is normally to the top level of the UniverseScheme. During development or when creating documentation from incomplete legacy materials this field should contain an appropriate statement such as "Under development", "Unavailable", "Not provided by creator", or other similar statement.Gets the value of the universeReference property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the universeReference property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getUniverseReference().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link ReferenceType }
     * 
     * 
     */
    public List<ReferenceType> getUniverseReference() {
        if (universeReference == null) {
            universeReference = new ArrayList<ReferenceType>();
        }
        return this.universeReference;
    }

    /**
     * Information regarding the official series of which a study unit or group of study units is a part. One may point to the URL of a series repository and then use the Name field to indicate the series itself as identified in that repository. Fields also exist for describing the series and providing abbreviations.
     * 
     * @return
     *     possible object is
     *     {@link SeriesStatementType }
     *     
     */
    public SeriesStatementType getSeriesStatement() {
        return seriesStatement;
    }

    /**
     * Sets the value of the seriesStatement property.
     * 
     * @param value
     *     allowed object is
     *     {@link SeriesStatementType }
     *     
     */
    public void setSeriesStatement(SeriesStatementType value) {
        this.seriesStatement = value;
    }

    /**
     * Contains details of the study unit's funding, including information about grants, agencies, etc.Gets the value of the fundingInformation property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the fundingInformation property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getFundingInformation().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link FundingInformationType }
     * 
     * 
     */
    public List<FundingInformationType> getFundingInformation() {
        if (fundingInformation == null) {
            fundingInformation = new ArrayList<FundingInformationType>();
        }
        return this.fundingInformation;
    }

    /**
     * The purpose of the study, in human-readable form. This should include detailed information on the investigator's primary study questions or hypotheses as well as information on any legal basis for the data collection, such as laws requiring the collection of census data for apportionment purposes. During study development, or when creating documentation from incomplete legacy materials, this field should contain an appropriate statement such as "Under development", "Unavailable", "Not provided by creator", or some other similar statement.Gets the value of the purpose property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the purpose property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getPurpose().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link IdentifiedStructuredStringType }
     * 
     * 
     */
    public List<IdentifiedStructuredStringType> getPurpose() {
        if (purpose == null) {
            purpose = new ArrayList<IdentifiedStructuredStringType>();
        }
        return this.purpose;
    }

    /**
     * Describes the coverage of the study unit. Detailed information on Topical, Temporal, and Spatial Coverage is contained here. Note that Coverage at this level should be inclusive all all lower level modules or section. Lower level descriptions serve to constrain coverage within the scope described here.
     * 
     * @return
     *     possible object is
     *     {@link CoverageType }
     *     
     */
    public CoverageType getCoverage() {
        return coverage;
    }

    /**
     * Sets the value of the coverage property.
     * 
     * @param value
     *     allowed object is
     *     {@link CoverageType }
     *     
     */
    public void setCoverage(CoverageType value) {
        this.coverage = value;
    }

    /**
     * Allows the use of a controlled vocabulary to list all of the units of analysis used in the study. Should be repeated to describe multiple units of analysis.Gets the value of the analysisUnit property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the analysisUnit property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getAnalysisUnit().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link CodeValueType }
     * 
     * 
     */
    public List<CodeValueType> getAnalysisUnit() {
        if (analysisUnit == null) {
            analysisUnit = new ArrayList<CodeValueType>();
        }
        return this.analysisUnit;
    }

    /**
     * A narrative of the units of analysis in the study unit. May be repeated to provide for multiple-language support.Gets the value of the analysisUnitsCovered property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the analysisUnitsCovered property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getAnalysisUnitsCovered().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link InternationalStringType }
     * 
     * 
     */
    public List<InternationalStringType> getAnalysisUnitsCovered() {
        if (analysisUnitsCovered == null) {
            analysisUnitsCovered = new ArrayList<InternationalStringType>();
        }
        return this.analysisUnitsCovered;
    }

    /**
     * Describes, with a string or a term from a controlled vocabulary, the kind of data documented in the logical product(s) of a study unit. Examples include survey data, census/enumeration data, administrative data, measurement data, assessment data, demographic data, voting data, etc.Gets the value of the kindOfData property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the kindOfData property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getKindOfData().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link KindOfDataType }
     * 
     * 
     */
    public List<KindOfDataType> getKindOfData() {
        if (kindOfData == null) {
            kindOfData = new ArrayList<KindOfDataType>();
        }
        return this.kindOfData;
    }

    /**
     * Contains references to other materials relevent to the study unit, whether in DDI form or external. References can be made from items in this section to any identifiable element in the instance.Gets the value of the otherMaterial property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the otherMaterial property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getOtherMaterial().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link OtherMaterialType }
     * 
     * 
     */
    public List<OtherMaterialType> getOtherMaterial() {
        if (otherMaterial == null) {
            otherMaterial = new ArrayList<OtherMaterialType>();
        }
        return this.otherMaterial;
    }

    /**
     * Contains notes pertinent to the study unit and its contents. References can be made from items in this section to any identifiable element in the instance.Gets the value of the note property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the note property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getNote().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link NoteType }
     * 
     * 
     */
    public List<NoteType> getNote() {
        if (note == null) {
            note = new ArrayList<NoteType>();
        }
        return this.note;
    }

    /**
     * Embargo information about the study unit. References to embargo information in this section can be made from individual variables.Gets the value of the embargo property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the embargo property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getEmbargo().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link EmbargoType }
     * 
     * 
     */
    public List<EmbargoType> getEmbargo() {
        if (embargo == null) {
            embargo = new ArrayList<EmbargoType>();
        }
        return this.embargo;
    }

    /**
     * Contains documentation and metadata regarding the concepts and universes used by the study unit. This includes over-rides for documentation and metadata inherited from parent groups, if any.Gets the value of the conceptualComponent property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the conceptualComponent property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getConceptualComponent().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link ConceptualComponentType }
     * 
     * 
     */
    public List<ConceptualComponentType> getConceptualComponent() {
        if (conceptualComponent == null) {
            conceptualComponent = new ArrayList<ConceptualComponentType>();
        }
        return this.conceptualComponent;
    }

    /**
     * Gets the value of the conceptualComponentReference property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the conceptualComponentReference property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getConceptualComponentReference().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link ReferenceType }
     * 
     * 
     */
    public List<ReferenceType> getConceptualComponentReference() {
        if (conceptualComponentReference == null) {
            conceptualComponentReference = new ArrayList<ReferenceType>();
        }
        return this.conceptualComponentReference;
    }

    /**
     * Contains documentation and metadata regarding the data collection methods and processes of the study unit. This includes over-rides for documentation and metadata inherited from parent groups, if any.Gets the value of the dataCollection property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the dataCollection property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getDataCollection().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link DataCollectionType }
     * 
     * 
     */
    public List<DataCollectionType> getDataCollection() {
        if (dataCollection == null) {
            dataCollection = new ArrayList<DataCollectionType>();
        }
        return this.dataCollection;
    }

    /**
     * Gets the value of the dataCollectionReference property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the dataCollectionReference property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getDataCollectionReference().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link ReferenceType }
     * 
     * 
     */
    public List<ReferenceType> getDataCollectionReference() {
        if (dataCollectionReference == null) {
            dataCollectionReference = new ArrayList<ReferenceType>();
        }
        return this.dataCollectionReference;
    }

    /**
     * Contains documentation and metadata regarding the logical data products of the study unit. This includes over-rides for documentation and metadata inherited from parent groups, if any.Gets the value of the baseLogicalProduct property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the baseLogicalProduct property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getBaseLogicalProduct().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link JAXBElement }{@code <}{@link LogicalProductType }{@code >}
     * {@link JAXBElement }{@code <}{@link NCubeLogicalProductType }{@code >}
     * {@link JAXBElement }{@code <}{@link BaseLogicalProductType }{@code >}
     * 
     * 
     */
    public List<JAXBElement<? extends BaseLogicalProductType>> getBaseLogicalProduct() {
        if (baseLogicalProduct == null) {
            baseLogicalProduct = new ArrayList<JAXBElement<? extends BaseLogicalProductType>>();
        }
        return this.baseLogicalProduct;
    }

    /**
     * Gets the value of the logicalProductReference property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the logicalProductReference property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getLogicalProductReference().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link ReferenceType }
     * 
     * 
     */
    public List<ReferenceType> getLogicalProductReference() {
        if (logicalProductReference == null) {
            logicalProductReference = new ArrayList<ReferenceType>();
        }
        return this.logicalProductReference;
    }

    /**
     * Contains documentation and metadata regarding a physical structure of data products of the study unit.Gets the value of the physicalDataProduct property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the physicalDataProduct property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getPhysicalDataProduct().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link PhysicalDataProductType }
     * 
     * 
     */
    public List<PhysicalDataProductType> getPhysicalDataProduct() {
        if (physicalDataProduct == null) {
            physicalDataProduct = new ArrayList<PhysicalDataProductType>();
        }
        return this.physicalDataProduct;
    }

    /**
     * Gets the value of the physicalDataProductReference property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the physicalDataProductReference property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getPhysicalDataProductReference().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link ReferenceType }
     * 
     * 
     */
    public List<ReferenceType> getPhysicalDataProductReference() {
        if (physicalDataProductReference == null) {
            physicalDataProductReference = new ArrayList<ReferenceType>();
        }
        return this.physicalDataProductReference;
    }

    /**
     * Contains documentation and metadata regarding a physical instance of one of the data products of the study unit.Gets the value of the physicalInstance property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the physicalInstance property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getPhysicalInstance().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link PhysicalInstanceType }
     * 
     * 
     */
    public List<PhysicalInstanceType> getPhysicalInstance() {
        if (physicalInstance == null) {
            physicalInstance = new ArrayList<PhysicalInstanceType>();
        }
        return this.physicalInstance;
    }

    /**
     * Gets the value of the physicalInstanceReference property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the physicalInstanceReference property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getPhysicalInstanceReference().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link ReferenceType }
     * 
     * 
     */
    public List<ReferenceType> getPhysicalInstanceReference() {
        if (physicalInstanceReference == null) {
            physicalInstanceReference = new ArrayList<ReferenceType>();
        }
        return this.physicalInstanceReference;
    }

    /**
     * Archive serves as a packet containing both persistent and transient information. Describes archive-specific material including item record information as well as lifecycle information. The metadata in the package is divided into elements that are persistent (should remain with the Study Unit through its life-cycle), and transient (pertinent only to the Study Unit as held by that archive).
     * 
     * @return
     *     possible object is
     *     {@link ArchiveType }
     *     
     */
    public ArchiveType getArchive() {
        return archive;
    }

    /**
     * Sets the value of the archive property.
     * 
     * @param value
     *     allowed object is
     *     {@link ArchiveType }
     *     
     */
    public void setArchive(ArchiveType value) {
        this.archive = value;
    }

    /**
     * Gets the value of the archiveReference property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the archiveReference property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getArchiveReference().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link ReferenceType }
     * 
     * 
     */
    public List<ReferenceType> getArchiveReference() {
        if (archiveReference == null) {
            archiveReference = new ArrayList<ReferenceType>();
        }
        return this.archiveReference;
    }

    /**
     * Contains a DDI Profile which is used by the study unit, and which can be referenced externally.Gets the value of the ddiProfile property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the ddiProfile property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getDDIProfile().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link DDIProfileType }
     * 
     * 
     */
    public List<DDIProfileType> getDDIProfile() {
        if (ddiProfile == null) {
            ddiProfile = new ArrayList<DDIProfileType>();
        }
        return this.ddiProfile;
    }

    /**
     * References a DDI Profile used by the study unit Gets the value of the ddiProfileReference property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the ddiProfileReference property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getDDIProfileReference().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link ReferenceType }
     * 
     * 
     */
    public List<ReferenceType> getDDIProfileReference() {
        if (ddiProfileReference == null) {
            ddiProfileReference = new ArrayList<ReferenceType>();
        }
        return this.ddiProfileReference;
    }

}
