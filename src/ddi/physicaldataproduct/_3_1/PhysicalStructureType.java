//
// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, v2.2.4 
// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> 
// Any modifications to this file will be lost upon recompilation of the source schema. 
// Generated on: 2013.08.22 at 02:00:24 PM CEST 
//


package ddi.physicaldataproduct._3_1;

import java.math.BigInteger;
import java.util.ArrayList;
import java.util.List;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlType;
import ddi.reusable._3_1.ReferenceType;
import ddi.reusable._3_1.VersionableType;


/**
 * Description of a physical structure .These are used by record layouts to describe the full structure of a physical instance.
 * 
 * <p>Java class for PhysicalStructureType complex type.
 * 
 * <p>The following schema fragment specifies the expected content contained within this class.
 * 
 * <pre>
 * &lt;complexType name="PhysicalStructureType">
 *   &lt;complexContent>
 *     &lt;extension base="{ddi:reusable:3_1}VersionableType">
 *       &lt;sequence>
 *         &lt;element ref="{ddi:physicaldataproduct:3_1}LogicalProductReference" maxOccurs="unbounded"/>
 *         &lt;element name="Format" type="{http://www.w3.org/2001/XMLSchema}string" minOccurs="0"/>
 *         &lt;element name="DefaultDataType" type="{http://www.w3.org/2001/XMLSchema}string" minOccurs="0"/>
 *         &lt;element name="DefaultDelimiter" type="{http://www.w3.org/2001/XMLSchema}string" minOccurs="0"/>
 *         &lt;element name="DefaultDecimalPositions" type="{http://www.w3.org/2001/XMLSchema}integer" minOccurs="0"/>
 *         &lt;element ref="{ddi:physicaldataproduct:3_1}DefaultDecimalSeparator" minOccurs="0"/>
 *         &lt;element ref="{ddi:physicaldataproduct:3_1}DefaultDigitGroupSeparator" minOccurs="0"/>
 *         &lt;element name="DefaultMissingData" type="{http://www.w3.org/2001/XMLSchema}string" minOccurs="0"/>
 *         &lt;element ref="{ddi:physicaldataproduct:3_1}GrossRecordStructure" maxOccurs="unbounded"/>
 *       &lt;/sequence>
 *     &lt;/extension>
 *   &lt;/complexContent>
 * &lt;/complexType>
 * </pre>
 * 
 * 
 */
@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "PhysicalStructureType", propOrder = {
    "logicalProductReference",
    "format",
    "defaultDataType",
    "defaultDelimiter",
    "defaultDecimalPositions",
    "defaultDecimalSeparator",
    "defaultDigitGroupSeparator",
    "defaultMissingData",
    "grossRecordStructure"
})
public class PhysicalStructureType
    extends VersionableType
{

    @XmlElement(name = "LogicalProductReference", required = true)
    protected List<ReferenceType> logicalProductReference;
    @XmlElement(name = "Format")
    protected String format;
    @XmlElement(name = "DefaultDataType")
    protected String defaultDataType;
    @XmlElement(name = "DefaultDelimiter")
    protected String defaultDelimiter;
    @XmlElement(name = "DefaultDecimalPositions")
    protected BigInteger defaultDecimalPositions;
    @XmlElement(name = "DefaultDecimalSeparator")
    protected String defaultDecimalSeparator;
    @XmlElement(name = "DefaultDigitGroupSeparator")
    protected String defaultDigitGroupSeparator;
    @XmlElement(name = "DefaultMissingData")
    protected String defaultMissingData;
    @XmlElement(name = "GrossRecordStructure", required = true)
    protected List<GrossRecordStructureType> grossRecordStructure;

    /**
     * References the logical data product that describes the intellectual content of this physical data product.Gets the value of the logicalProductReference property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the logicalProductReference property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getLogicalProductReference().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link ReferenceType }
     * 
     * 
     */
    public List<ReferenceType> getLogicalProductReference() {
        if (logicalProductReference == null) {
            logicalProductReference = new ArrayList<ReferenceType>();
        }
        return this.logicalProductReference;
    }

    /**
     * Gets the value of the format property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */
    public String getFormat() {
        return format;
    }

    /**
     * Sets the value of the format property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */
    public void setFormat(String value) {
        this.format = value;
    }

    /**
     * Gets the value of the defaultDataType property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */
    public String getDefaultDataType() {
        return defaultDataType;
    }

    /**
     * Sets the value of the defaultDataType property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */
    public void setDefaultDataType(String value) {
        this.defaultDataType = value;
    }

    /**
     * Gets the value of the defaultDelimiter property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */
    public String getDefaultDelimiter() {
        return defaultDelimiter;
    }

    /**
     * Sets the value of the defaultDelimiter property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */
    public void setDefaultDelimiter(String value) {
        this.defaultDelimiter = value;
    }

    /**
     * Gets the value of the defaultDecimalPositions property.
     * 
     * @return
     *     possible object is
     *     {@link BigInteger }
     *     
     */
    public BigInteger getDefaultDecimalPositions() {
        return defaultDecimalPositions;
    }

    /**
     * Sets the value of the defaultDecimalPositions property.
     * 
     * @param value
     *     allowed object is
     *     {@link BigInteger }
     *     
     */
    public void setDefaultDecimalPositions(BigInteger value) {
        this.defaultDecimalPositions = value;
    }

    /**
     * The character used to separate the integer and the fraction part of a number (if an explicit separator is used in the data) that is applied to the majority of the dataitems reducing the amount of repetitive markup required. It can be overridden at the dataitem level. Allowed values are: None (default), Dot, Comma, Other. On the basis of the data definition in DDI documents, data processing tools could compute the necessary precision width on the basis of the format width and the existence of separators. Appropriate data types could be used, i.e. float or double, short or long. The decimal separator definition only makes sense with some XML Schema primitives. This is a default which may be overridden in specific cases.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */
    public String getDefaultDecimalSeparator() {
        return defaultDecimalSeparator;
    }

    /**
     * Sets the value of the defaultDecimalSeparator property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */
    public void setDefaultDecimalSeparator(String value) {
        this.defaultDecimalSeparator = value;
    }

    /**
     * The character used to separate groups of digits (if an explicit separator is used in the data) that is applied to the majority of the dataitems reducing the amount of repetitive markup required. It can be overridden at the dataitem level. Allowed values are: None (default), Dot, Comma, Other. The decimal separator definition makes only sense with some XML Schema primitives. This is a default which may be overridden in specific cases.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */
    public String getDefaultDigitGroupSeparator() {
        return defaultDigitGroupSeparator;
    }

    /**
     * Sets the value of the defaultDigitGroupSeparator property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */
    public void setDefaultDigitGroupSeparator(String value) {
        this.defaultDigitGroupSeparator = value;
    }

    /**
     * Gets the value of the defaultMissingData property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */
    public String getDefaultMissingData() {
        return defaultMissingData;
    }

    /**
     * Sets the value of the defaultMissingData property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */
    public void setDefaultMissingData(String value) {
        this.defaultMissingData = value;
    }

    /**
     * Characteristics of the physical storage of a logical record, as described in the DataRelationship section of the logical product.Gets the value of the grossRecordStructure property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the grossRecordStructure property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getGrossRecordStructure().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link GrossRecordStructureType }
     * 
     * 
     */
    public List<GrossRecordStructureType> getGrossRecordStructure() {
        if (grossRecordStructure == null) {
            grossRecordStructure = new ArrayList<GrossRecordStructureType>();
        }
        return this.grossRecordStructure;
    }

}
